package _05锦标赛;

public class Main {
    //a 表示待处理的数据，长度如果不是2的次幂，则不足位置补为-1
    static void pick(int[] a) {
        int n = 1;
        while (n < a.length) n *= 2;


        int[] b = new int[2 * n - 1];
        for (int i = 0; i < n; i++) {
            if (i < a.length)
                b[n - 1 + i] = i;
            else
                b[n - 1 + i] = -1;
        }

        //从最后一个向前处理
        for (int i = b.length - 1; i > 0; i -= 2) {
            if (b[i] < 0) {
                if (b[i - 1] >= 0)
                    b[(i - 1) / 2] = b[i - 1];
                else
                    b[(i - 1) / 2] = -1;
            } else {
                if (a[b[i]] > a[b[i - 1]])
                    b[(i - 1) / 2] = b[i];
                else
                    b[(i - 1) / 2] = b[i - 1];
            }
        }

        //输出树根
        System.out.println(b[0] + ": " + a[b[0]]);

        //值等于根元素的位置需要重新pk
        pk(a, b, 0, b[0]);

        //再次输出树根
        System.out.println(b[0] + ": " + a[b[0]]);
    }

    // a 表示待处理数据，b 二叉树，k 当前要重新比拼的位置，v 已经决胜出的值的索引

    static void pk(int[] a, int[] b, int k, int v) {

        int k1 = k * 2 + 1;//左子树下标
        int k2 = k1 + 1;//右子树下标

        //递归终止条件
        //如果以k为根节点的左右子树下标k1和k2，如果k1或k2 比二叉树的长度还长。则根节点k在二叉树的最后一层
        //这段*****括起来的代码的语义是: 将二叉树b中 以k为根节点的二叉树的最后一层中的结点值为v
        // 即a[v]=max(也就是22)的点的内容置为-1
        // 也就是9:-1
//******************************************
        if (k1 >= b.length || k2 >= b.length) {
            b[k] = -1;
            return;
        }
        if (b[k1] == v)
            pk(a, b, k1, v);
        else
            pk(a, b, k2, v);
//******************************************

        //重新比较
        // k=9 k1=19 k2=20 所以将b[9] = -1 之后因为递归到底后return了
        // 所以返回上一层之后 根节点 k = 4，此时左右子树 k1=9 k2=10
        // 下面这行代码见我在main函数下面的注释6和注释7
        if (b[k1] < 0) {       //左子树-1 右子树大于0
            if (b[k2] >= 0)    //将右子树存放的值(数组a才使用的index)放入根节点
                b[k] = b[k2];
            else
                b[k] = -1;
            return;
        }

        if (b[k2] < 0) {
            if (b[k1] >= 0)
                b[k] = b[k1];
            else
                b[k] = -1;
            return;
        }

        if (a[b[k1]] > a[b[k2]])  //填空
            b[k] = b[k1];
        else
            b[k] = b[k2];
    }

    public static void main(String[] args) {
        int[] arr = new int[]{1, 8, 22, 15, 3, 6, 12, 13};
        pick(arr);
    }
    /**  arr有 8个数据索引为0~7 。：前是左右字数的下标。而数组二叉树b存储的即冒号后的是index。括号()里面的数字是a[index]
     *   8个元素开 2*8-1 = 15个空间 可以看如下二叉树的图形
     *   左子树的下标是2*k+1 右子树下标是2*k+2 int[] arr = new int[]{1, 8, 22, 15, 3, 6, 12, 13};
     *   1:
     *                                       0:0
     *                        /                              \
     *                    1:0                               2:0
     *               /         \                     /            \
     *            3:0         4:0                 5:0             6:0
     *          /    \       /    \             /    \          /    \
     *      7:0(1) 8:1(8) 9:2(22) 10:3(15) 11:4(3) 12:5(6) 13:6(12)  14:7(13)
     *   2:
     *                                       0:0
     *                        /                              \
     *                    1:0                               2:0
     *               /         \                     /            \
     *            3:1(8)     4:2(22)              5:5(6)         6:7(13)
     *          /    \       /    \             /    \          /    \
     *      7:0(1) 8:1(8) 9:2(22) 10:3(15) 11:4(3) 12:5(6) 13:6(12)  14:7(13)
     *
     *   3:
     *                                       0:0
     *                        /                              \
     *                    1:2(22)                           2:7(13)
     *               /         \                     /            \
     *             3:1(8)     4:2(22)              5:5(6)         6:7(13)
     *          /    \       /    \             /    \          /    \
     *      7:0(1) 8:1(8) 9:2(22) 10:3(15) 11:4(3) 12:5(6) 13:6(12)  14:7(13)
     *   4:
     *                                       0:2(22)
     *                        /                              \
     *                    1:2(22)                           2:7(13)
     *               /         \                     /            \
     *             3:1(8)     4:2(22)              5:5(6)         6:7(13)
     *          /    \       /    \             /    \          /    \
     *      7:0(1) 8:1(8) 9:2(22) 10:3(15) 11:4(3) 12:5(6) 13:6(12)  14:7(13)
     *
     *  5: 打印第一大的数字 即 2 : 22
     *
     *  6: 最后一层 因为 b[9] = 2, a[b[9]]=22  所以b[9] = -1
     *
     *                                       0:2(22)
     *                        /                              \
     *                    1:2(22)                           2:7(13)
     *               /         \                     /            \
     *             3:1(8)     4:2(22)              5:5(6)         6:7(13)
     *          /    \       /    \             /    \          /    \
     *      7:0(1) 8:1(8) 9:-1 10:3(15) 11:4(3) 12:5(6) 13:6(12)  14:7(13)
     *                   k=9 k1=19 k2=20 之后因为递归到底后return了
     *                   返回上一层之后 根节点 k = 4，此时左右子树 k1=9 k2=10
     *                  再重新比较左右子数，将值为非-1的子树的值，传给根节点,见7
     *
     *  7:  ！说明这个数字变化了
     *                                      0:2(22)
     *                        /                              \
     *                    1:2(22)                           2:7(13)
     *               /         \                     /            \
     *             3:1(8)     4:3(15)！            5:5(6)         6:7(13)
     *          /    \       /    \             /    \          /    \
     *      7:0(1) 8:1(8) 9:-1 10:3(15) 11:4(3) 12:5(6) 13:6(12)  14:7(13)
     *          以此类推
     *
     *  8:  ！说明这个数字变化了
     *                                      0:2(22)
     *                        /                              \
     *                    1:3(15)！                          2:7(13)
     *               /         \                     /            \
     *             3:1(8)     4:3(15)            5:5(6)         6:7(13)
     *          /    \       /    \             /    \          /    \
     *      7:0(1) 8:1(8) 9:-1 10:3(15) 11:4(3) 12:5(6) 13:6(12)  14:7(13)
     *
     *  9:  ！说明这个数字变化了
     *                                      0:3(15)!
     *                        /                              \
     *                    1:3(15)                          2:7(13)
     *               /         \                     /            \
     *             3:1(8)     4:3(15)            5:5(6)         6:7(13)
     *          /    \       /    \             /    \          /    \
     *      7:0(1) 8:1(8) 9:-1 10:3(15) 11:4(3) 12:5(6) 13:6(12)  14:7(13)
     *
     *  10:  打印二叉树的根节点
     *
     *  11:int[] arr = new int[]{1, -8, 22, -15, -3, -6, -12, -13};
     *                                       0:2(22)
     *                        /                              \
     *                    1:2(22)                               2:4(-3)
     *               /         \                            /            \
     *             3:0(1)       4:2(22)                 5:4(-3)         6:6(-12)
     *          /    \         /    \              /    \            /    \
     *      7:0(1) 8:1(-8) 9:2(22) 10:3(-15) 11:4(-3) 12:5(-6) 13:6(-12)  14:7(-13)
     *
     *  12:
     *                                       0:2(22)
     *                        /                              \
     *                    1:2(22)                           2:4(-3)
     *               /         \                          /            \
     *             3:0(1)       4:2(22)              5:4(-3)         6:6(-12)
     *          /    \       /         \             /    \          /    \
     *      7:0(1) 8:1(-8) 9:-1(22) 10:3(-15) 11:4(-3) 12:5(-6) 13:6(-12)  14:7(-13)
     *
     *  13:
     *                                       0:2(22)
     *                        /                              \
     *                    1:2(22)                           2:4(-3)
     *               /         \                     /            \
     *             3:0(1)     4:3(-15)            5:4(-3)         6:6(-12)
     *          /    \       /    \             /    \          /    \
     *      7:0(1) 8:1(-8) 9:-1(22) 10:3(-15) 11:4(-3) 12:5(-6) 13:6(-12)  14:7(-13)
     *
     *  14:
     *                                       0:2(22)
     *                        /                              \
     *                    1:0(1)                           2:4(-3)
     *               /         \                     /            \
     *             3:0(1)     4:3(-15)!              5:4(-3)         6:6(-12)
     *          /    \       /    \             /    \          /    \
     *      7:0(1) 8:1(-8) 9:-1(22) 10:3(-15) 11:4(-3) 12:5(-6) 13:6(-12)  14:7(-13)
     *
     *  15:
     *                                       0:2(22)
     *                        /                              \
     *                    1:0(1) !                          2:4(-3)
     *               /         \                     /            \
     *             3:0(1)     4:3(-15)              5:4(-3)         6:6(-12)
     *          /    \       /    \             /    \          /    \
     *      7:0(1) 8:1(-8) 9:-1(22) 10:3(-15) 11:4(-3) 12:5(-6) 13:6(-12)  14:7(-13)
     *
     *  16:
     *                                       0:0(1)！
     *                        /                              \
     *                    1:0(1)                           2:4(-3)
     *               /         \                     /            \
     *             3:0(1)     4:3(-15)            5:4(-3)         6:6(-12)
     *          /    \       /    \             /    \          /    \
     *      7:0(1) 8:1(-8) 9:-1(22) 10:3(-15) 11:4(-3) 12:5(-6) 13:6(-12)  14:7(-13)
     *
     *
     *
     *
     */
}
