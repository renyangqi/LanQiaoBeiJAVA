package _07绳圈;

/**
 * Num[i][j] 即i根绳子组成j个圈方法数的
 * Num[i][j] = Num[i-1][j-1] + Num[i-1][j]*(i-1)*2
 * 解释:
 * 由i根绳子组成j个圈的分成两种情况
 * 1: 即最后一根绳子自成一圈: 那么其方法数就是，由i-1根绳子生成j-1个圈的个数,为Num[i-1][j-1]
 * 2: 最后一根绳子穿入形成j个圈: 那么首先就要知道 由i-1根绳子生成j的圈的方法数。即Num[i-1][j]。
 * (重点其中组成Num[i-1][j]中的每一种方式都是有n-1根绳子组成)！ 換句話說每种方式都有(i-1)插入点个点可以插入
 * 使得原来的j圈加入最后一根绳后还是j圈 每根绳子有两根绳头 A,B 对于同一个插入点可以插入A也可以插入B所以要乘以2
 * 即Num[i-1][j]*(i-1)*2
 * 因此:Num[i][j] = Num[i-1][j-1] + Num[i-1][j]*(i-1)*2
 * 这道题问100根绳子组成几个圈的概率最大,其实问的是 100根绳子组成1个圈的方法数 2个圈的方法数....100个圈的方法数
 * 再除以100根绳子一共有多少种绕圈的方法数即c[100](再次强调!每种方法都用到了全部的100根绳子)
 * c[i-1] 代表i-1根绳子能够有多少种绕圈的方式。重点!(每一种方式都是有i-1根绳子组成,換句話說每种方式都有(i-1)插入点)
 * <p>
 * 拓展求c[i]的方法
 * c[i] = c[i-1] + c[i-1] * (i-1) * 2 = c[i-1]*(2i-1)
 * 解释:
 * c[i-1] 代表i-1根绳子能过有多少种绕圈的方式。重点!(一种方式都是有n-1根绳子组成,換句話說每种方式都有(i-1)插入点)
 * 求c[i] 分两种情况
 * 1:最后一根(第i根)绳子不插入，自成一圈:其数目为 c[i-1]
 * 2:最后一根绳子插入: i-1根绳子的每一种绕圈方式有 i-1个插入点,同一个插入点可以插入最后一根绳子的A或B端,
 * 因此乘 2。一共有c[i-1]种绕圈的方式 故第二种情况的方法数为c[i-1]*(i-1)*2
 * 结论;两种情况加起来则:c[i] = c[i-1] + c[i-1] * (i-1) * 2 = c[i-1]*(2i-1)
 * <p>
 * 总结
 * F[i][j]定义成i根绳子组成j个圈的概率,则f[i][j] = N[i][j]/c[i]
 * <p>
 * Num[i][j] 即i根绳子组成j个圈方法数的
 * Num[i][j] = Num[i-1][j-1] + Num[i-1][j]*(i-1)*2
 * f[i][j] = N[i][j]/c[i]
 * c[i]=c[i-1]*(2i-1)
 * <p>
 *          f[i][j] = [Num[i-1][j-1] + Num[i-1][j]*(i-1)*2]
 *                   --------------------------------------------
 *                      c[i-1]*(2i-1)
 * <p>
 *                  = [f[i-1][j-1] + f[i-1][j]*(i-1)*2]
 *                   --------------------------------------------
 *                      （2i-1）
 */
public class Main {



    public static void main(String[] args) {


        // Num[i][j] 即i根绳子组成j个圈方法数的
        // Num[i][j] = Num[i-1][j-1] + Num[i-1][j]*(i-1)*2
        // c[i]=c[i-1]*(2i-1)
        // f[i][j] = N[i][j]/c[i]

        //f[i][j] = [Num[i-1][j-1] + Num[i-1][j]*(i-1)*2]
        //         --------------------------------------------
        //           c[i-1]*(2i-1)

        //        = [f[i-1][j-1] + f[i-1][j]*(i-1)*2]
        //         --------------------------------------------
        //          （2i-1）
        //         这就是f[i][j]的递推公式(状态转移方程)

        //动态规划  有点像0-1背包问题
        double[][] F = new double[101][101];
        F[1][1] = 1;
        for (int i = 2; i <= 100; i++)
            for (int j = 1; j <= i; j++)
                F[i][j] = (F[i - 1][j - 1] + F[i - 1][j] * (i - 1) * 2)/(2*i-1);//F[i][j]的状态转移方程
        int maxIndex = 1;
        for (int i = 1; i <= 100; i++)
            if(F[100][i]>F[100][maxIndex])
                maxIndex = i;
        System.out.println(maxIndex);//写了10行代码就解决了问题, 但为了说明F[i][j]这个状态转移方程,写了60多行注释
        // 注意如果分别求出 Num[i][j],c[i]再相除会出错,因为数字太大会出现溢出的情况
    }
}
